# 循环依赖

类A依赖类B，类B也依赖类A，这种情况就会出现循环依赖。 Bean A → Bean B → Bean A

循环依赖会导致`内存溢出`

```java
public class AService {
private BService bService = new BService();
}

public class BService {
private AService aService = new AService();
}
```

当通过 new AService() 创建一个对象时你会获得一个栈溢出的错误
因为调用 new AService() 时会先去执行属性 bService 的初始化, 而 bService 的初始化又会去执行AService 的初始化， 这样就形成了一个循环调用，最终导致调用栈内存溢出。

## 简单解决循环依赖

```java
    // 模拟spring解决循环依赖的缓存 key存类名 value存bean实例，防止循环依赖后不断创建新对象导致栈内存溢出
    private static Map<String, Object> cacheMap = new HashMap<>();

    public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        Class[] classes = {Dept.class, Stuff.class};
        for (Class classA : classes) {
            //获取bean
            getBean(classA);
        }

        System.out.println(getBean(Stuff.class).getDept() == getBean(Dept.class));
        System.out.println(getBean(Dept.class).getStuff() == getBean(Stuff.class));

    }
	
    public static <T> T getBean(Class<T> bean) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        // 获取要创建的bean的类名
        String beanName = bean.getSimpleName().toLowerCase();

        // 判断缓存map的key里面是否有该类名
        if (cacheMap.containsKey(beanName)) {
            //存在直接返回实例bean
            return (T) cacheMap.get(beanName);
        }
        //不存在类名，使用反射得到实例化的bean  obj
        Object obj = bean.getDeclaredConstructor().newInstance();
        //将实例化的bean和类名存入缓存map中
        cacheMap.put(beanName, obj);
        
        //获取bean里面的属性
        Field[] fields = obj.getClass().getDeclaredFields();


        //设置的是bean里面的属性
        for (Field field : fields) {
            field.setAccessible(true);
            Class<?> fieldType = field.getType();
			//属性的类名
            String fieldName = fieldType.getSimpleName().toLowerCase();
            // 第一参数是表示【这个field是属于哪个对象的】，第二个参数放set的值
            //这里第二个查询在缓存map里查找是否有该属性类名的bean，存在直接取出来set进去，不存在递归调用getBean()创建该类的bean
            field.set(obj, cacheMap.containsKey(fieldName)?cacheMap.get(fieldName): getBean(fieldType));
        }
        //最后返回bean
        return (T) obj;
    }
```

## spring是如何解决循环依赖的

三级缓存

1. `singletonObjects`：用于存放完全初始化好的 bean，**从该缓存中取出的 bean 可以直接使用**
2. `earlySingletonObjects`：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖
3. `singletonFactories`：存放单例对象工厂对象，用于处理使用了AOP的单例对象，通过存在value中的工厂，可以获取到代理对象

参考：尚硅谷周瑜的手写spring

Bean 创建的生命周期，主要三大部分：
Bean的实例化
Bean属性填充
Bean的初始化

主要逻辑在`AbstractAutowireCapableBeanFactory`类中的`doCreateBean`方法中

- 实例化

  ```java
  // Instantiate the bean.
  BeanWrapper instanceWrapper = null;
  if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
  }
  if (instanceWrapper == null) {
      instanceWrapper = createBeanInstance(beanName, mbd, args);
  }
  Object bean = instanceWrapper.getWrappedInstance();
  Class<?> beanType = instanceWrapper.getWrappedClass();
  if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
  }
  ```

  具体发生了什么不在这个深究
  理解为创建了一个Bean的原始对象，还没有对其中的属性进行填充
  ==重要：==原始对象创建完成后，如果当前bean处于创建中，并且开启了循环依赖的配置，那么，就调用`addSingletonFactory`，将工厂对象缓存在第三个Map中

  ```java
  // Eagerly cache singletons to be able to resolve circular references
  // even when triggered by lifecycle interfaces like BeanFactoryAware.
  boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
        isSingletonCurrentlyInCreation(beanName));
  if (earlySingletonExposure) {
     if (logger.isTraceEnabled()) {
        logger.trace("Eagerly caching bean '" + beanName +
              "' to allow for resolving potential circular references");
     }
      //往第三个Map中存入beanName对应的一个ObjectFactory，该工厂对象通过lambda传入一个方法
      //该方法就是用于在循环依赖发生后，创建AOP或者返回原始对象的方法
     addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
  }
  ```

- 属性填充

  populateBean(beanName, mbd, instanceWrapper);
  填充属性的时候，其实就是获取bean的需要注入的属性，并获取从容器中获取对应的bean，获取bean主要用到的方法`getSingleton`

  ```java
  protected Object getSingleton(String beanName, boolean allowEarlyReference) {
     // Quick check for existing instance without full singleton lock
      //先从第一个Map中获取成品Bean
     Object singletonObject = this.singletonObjects.get(beanName);
     if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        //第一个Map中没有，从第二个Map中获取半成品Map
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            //如果半成品也没有，那就需要从第三个Map中获取工厂对象来获取半成品Bean
            //加锁保证单例性
           synchronized (this.singletonObjects) {
              // Consistent creation of early reference within full singleton lock
              singletonObject = this.singletonObjects.get(beanName);
              if (singletonObject == null) {
                 singletonObject = this.earlySingletonObjects.get(beanName);
                 if (singletonObject == null) {
                    ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                    if (singletonFactory != null) {
                        //获取工厂对象，调用工厂对象的getObject方法，其中会判断该bean是否需要创建AOP
                       singletonObject = singletonFactory.getObject();
                        //创建好的对象，放进第二个Map
                       this.earlySingletonObjects.put(beanName, singletonObject);
                       //从第三个Map中删除对应工厂对象，保证单例性
                       this.singletonFactories.remove(beanName);
                    }
                 }
              }
           }
        }
     }
     return singletonObject;
  }
  ```

  获取bean的过程就是从三个Map中依次找是否有对应的对象可以获取

- 初始化

  其中就有AOP代理对象正常创建过程，如果创建bean没有使用第三个map的工厂创建代理对象，那会在这创建代理对象

- 初始化后，再从三个Map中获取一次Bean对象，和初始化的Bean做比较，如果此时Bean对象不是同一个引用，那说明初始化后的Bean和缓存中存的单例Bean不是同一个Bean了，就会报错。


### 为什么使用第二个Map

假设只有的第一层Map，如果我们自己设计，那就是存放刚实例化后的Bean，引用不变的情况下，能够解决循环依赖的问题；
但是在Spring的基础上Spring的Bean生命周期设计是先于循环依赖产生的，如果按照Bean生命周期，如果使用一个Map，Map存放的一定成品Bean,缓存放在Bean初始化后插入。那是解决不了Spring框架中产生的循环依赖问题的。
缓存插入如果放在实例化后，又会产生其他问题，例如无法注入代理对象等等。
所以在Spring框架下，想使用一个Map解决循环依赖不合理，至少要引入第二个Map，用来存放刚实例化后的Bean

### 为什么使用第三个Map

两个Map能够解决普通的循环依赖问题

但是如果对bean使用了AOP，在bean正常创建初始化阶段，会由后置处理器创建出代理对象，最后得到的bean对象其实是代理对象。

如果一个需要AOP的Bean创建的时候存在循环依赖，如B中注入了A的原始对象，但是A在初始化后实际暴露是一个代理对象，但是此时B中还是A原始Bean的引用，这会导致B对象中的A对象在使用过程中的AOP失效。

因此要考虑如果是AOP，那在属性注入时，就注入一个代理对象，那假如在Bean实例化后就得向二级缓存中存入一个AOP代理对象，但是这样可能和Spring的设计不符合叭，而且循环依赖是少数，只在循环依赖发生时来创建AOP代理对象。

当一个Bean发生了循环依赖，并且需要创建AOP时才创建一个代理对象，所以引入第三个Map，只要开启了循环依赖的配置，bean实例化后就向Map中存入一个对应的工厂对象，当自己属性注入时有需要循环的注入自己本身，那在从Map中获取对象时，才利用工厂对象来判是否需要AOP并生成AOP代理对象，放在第二个Map中；加入这个Bean并没有发生循环依赖以及不需要AOP，那AOP代理对象就不会此创建。

我的理解就是，第三个Map是用来适配Spring自己正常的AOP生命周期，解决存在AOP情况下的循环依赖问题，也能保证第二个Map中存放的始终是半成品Bean